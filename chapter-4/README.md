# 第三章 任务

&emsp;&emsp;至此我们讨论了zone是如何创建、分叉，以及如何在异步操作之间维护状态的。运行时zone以执行堆栈帧嵌套完全相同的方式嵌套（但是通常层次会稍微浅一些）。在嵌套的过程中有一个zone很特殊，那就是最顶层的zone。如果执行上下文从JavaScript切换到原生宿主环境时这个zone还存在的话（另外一种描述方式是当最顶层执行堆栈帧退出，控制返回到原生代码），我们把这个最顶层的zone叫做**任务**。

```stacktrace
  at someOtherFn()[zoneB];
  at Zone.prototype.run()[zoneA -> zoneB]
  at someFn()[zoneA];
  at Zone.prototype.run()[<root> -> zoneA] <<< Task Frame / Zone
```

&emsp;&emsp;任务之所以特殊，在于如果知道任务何时退出对于下列场景很有用：

* 框架知道什么时候应该渲染界面
* 度量进入与离开可以知道总的脚本或是任务时长
* 退出时将执行权返回给原生代码，从而渲染或是执行I/O操作（知道将在什么时候发生就允许事务性行为的存在，比如渲染前执行某些任务，或是I/O）

&emsp;&emsp;知道任务何时进入、离开的必然结果，就是可以知道API调用何时创建将要、或者可能会执行的任务。

* 测试框架可以通过在任务创建时抛异常强制进行同步测试
* 测试框架可以自动检测异步测试，并通过等待所有计划任务完成自动等待测试的完成。
* 通过跟踪任务调度，可以得到跨异步操作的长堆栈跟踪。
* 通过跟踪用户触发的异步任务何时完成来跟踪用户感知的动作。

&emsp;&emsp;让人感兴趣的任务有三类：

1. 微任务：微任务是在空堆栈上会立即执行的任务。微任务保证在宿主环境执行渲染或是I/O操作之前执行。微任务队列必须在另一个微任务或是时间任务执行之前清空。（比如`Promise.then()`以微任务形式执行）
2. 宏任务：宏任务与宿主环境中的渲染以及I/O操作交替执行。（比如`setTimeout`，`setInterval`等等）宏任务保证至少执行一次，或是可以被取消（某些可以重复执行，比如`setInterval`）。宏任务有隐含的执行顺序。
3. 事件任务：事件任务与宏任务类似，但是区别在于它们可能永远不会执行。当事件任务执行，它会抢先清除宏任务队列的下一个任务，无论它是什么。时间任务不会创建队列。（例如，用户点击，鼠标移动，XHR状态改变）

| Type | Scheduled | Execution |
| - | - | - |
| 微任务 | 每当promise需要调用`thenCallback`就会调度微任务`promise.then(thenCallback)` | `thenCallback`执行在一个微任务中。一经调度，微任务无法取消，而是保证只执行一次。 |
| 宏任务 | 用户调用例如`setTimeout(callback)` `setInterval(callback)`这样的API就会调度宏任务 | 任意渲染或是I/O操作完成的时侯会在一个宏任务中执行`callback`。一旦完成，微任务队列会在执行控制交回给宿主环境，进行更多渲染以及I/O操作之前被清空。 |
| 事件任务 | 使用`addEventListener('click', eventCallback)`或是类似机制就会调度事件任务 | 事件任务也许永远不会执行，也可能发生在意想不到的时间，而且会发生多次，因为没有办法知道它到底会被执行多少次。 |

&emsp;&emsp;**任务为什么有用**：

* 知道什么时候任务执行完毕，或是微任务队列已空，使得框架知道什么去渲染界面。
* 强制不调度任何任务使得测试框架可以保证测试是同步的（进而执行速度快，并且流畅）。
* 跟踪何时所有调度的任务都执行完毕可以使得测试框架知道什么时候异步测试完成。
* 跟踪用户操作生成的任务并等待它们完成，使得应用程序可以跟踪这个操作的用户感知延迟。
* 知道所有任务何时执行完毕，使得端到端测试框架知道插入断言并进行下一步之前要等待多长时间。（这使得端到端测试更快，更流畅）

理解这种需求的另一种方式就是，如果没有任务的话以上各种行为是不可能实现的。
